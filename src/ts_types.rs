extern crate chrono;

use std::collections::{HashMap, HashSet};
use std::fmt::Write as _;
use std::fs::OpenOptions;
use std::io::Write;
use std::string::String;
use std::sync::{Arc, Mutex};

use anyhow::{anyhow, Result as AnyResult};
use regex::{Captures, NoExpand, Regex};
use serde::{Deserialize, Serialize};

use crate::{ReqBodyType, ResBodyType, YapiItem, YapiObj};

fn pascal_case(
    s: &str,
) -> String {
    let re = Regex::new(r"[._](\w)").unwrap();

    let s: String = s.split('/').last().map(|m| re.replace_all(m, |caps: &Captures| {
        caps[1].to_uppercase()
    }).to_string()).unwrap();
    let mut c = s.chars();
    match c.next() {
        None => String::new(),
        Some(f) =>
            f.to_uppercase().collect::<String>() + c.as_str(),
    }
}

#[derive(Debug, Deserialize, Serialize)]
pub struct ResponseValueType {
    r#type: String,
    description: Option<String>,
    items: Option<Box<ResponseValueType>>,
    properties: Option<HashMap<String, ResponseValueType>>,
    #[serde(rename(deserialize = "$$ref"))]
    __ref: Option<String>,
}

fn get_response_type_with_cb(value: &ResponseValueType, cb: &mut impl FnMut(String, String, usize), level: usize) -> String {
    match value.r#type.as_str() {
        "object" => {
            if let Some(properties) = &value.properties {
                let mut result = format!("\n// ref: {}\n", value.__ref.as_ref().unwrap());
                result.push_str("{\n");
                for (k, v) in properties {
                    writeln!(result, "{}:{}", k, get_response_type_with_cb(v, cb, level + 1)).unwrap();
                }
                result.push('}');
                match value.__ref {
                    Some(ref ref1) => {
                        let key = pascal_case(ref1);
                        cb(key.clone(), result, level);
                        return key;
                    }
                    None => {
                        return result;
                    }
                };
            }
            String::from("{}")
        }
        "array" => {
            if let Some(items) = &value.items {
                return format!("{}[]", get_response_type_with_cb(items, cb, level));
            }
            String::new()
        }
        "string" => String::from("string"),
        "integer" => String::from("number"),
        "boolean" => String::from("boolean"),
        _ => String::from("unknown"),
    }
}


fn get_response_type(value: &ResponseValueType) -> String {
    match value.r#type.as_str() {
        "object" => {
            if let Some(properties) = &value.properties {
                let mut result = format!("\n// ref: {}\n {{\n", value.__ref.as_ref().unwrap());
                for (k, v) in properties {
                    let _ = writeln!(result, "{}:{}", k, get_response_type(v));
                }
                result.push('}');
                return result;
            }
            String::from("{}")
        }
        "array" => {
            if let Some(items) = &value.items {
                return format!("{}[]", get_response_type(items));
            }
            String::new()
        }
        "string" => String::from("string"),
        "integer" => String::from("number"),
        "boolean" => String::from("boolean"),

        _ => String::from("unknown"),
    }
}

pub fn generate(data: &Vec<YapiObj>) -> AnyResult<()> {
    let map: Arc<Mutex<HashMap<String, String>>> = Arc::new(Mutex::new(HashMap::new()));
    let cb = |key: String, obj_str: String| {
        let mut map = map.lock().unwrap();
        map.entry(key).or_insert(obj_str);
    };
    let mut response_header = String::from("// generated by https://github.com/spike2044/yapi2js\n");
    let mut request_header = String::from("// generated by https://github.com/spike2044/yapi2js\n");
    let mut response = String::new();
    let mut request = String::new();

    let mut response_deps: HashSet<String> = HashSet::new();
    let mut request_deps: HashSet<String> = HashSet::new();
    let mut response_deps_cb = |key: String, obj_str: String, level: usize| {
        if level == 1 && !response_deps.contains(&key) {
            response_deps.insert(key.clone());
        }
        cb(key, obj_str);
    };
    let mut request_deps_cb = |key: String, obj_str: String, level: usize| {
        if level== 1 && !request_deps.contains(&key) {
            request_deps.insert(key.clone());
        }
        cb(key, obj_str);
    };
    let mut title_set = HashSet::new();
    for obj in data {
        for item in &obj.list {
            if title_set.contains(&item.title) {
                continue;
            } else {
                title_set.insert(item.title.clone());
            }
            if let Ok(response1) = generate_response(item, obj, &mut response_deps_cb) {
                response.push_str(&response1);
            }

            if let Ok(request1) = generate_request(item, obj, &mut request_deps_cb) {
                request.push_str(&request1);
            }
        }
    }

    let now = chrono::prelude::Local::now();

    writeln!(response_header, "// {}\nimport {{ {} }} from './types';", now.to_rfc2822(), response_deps.into_iter().collect::<Vec<String>>().join(", "))?;
    writeln!(request_header, "// {}\nimport {{ {} }} from './types';", now.to_rfc2822(), request_deps.into_iter().collect::<Vec<String>>().join(", "))?;

    response = response_header + &response;
    request = request_header + &request;

    if let Ok(mut file) = OpenOptions::new()
        .read(true)
        .write(true)
        .truncate(true)
        .create(true)
        .open("response.ts")
    {
        file.write_all(response.as_bytes())?;
    }

    if let Ok(mut file) = OpenOptions::new()
        .read(true)
        .write(true)
        .truncate(true)
        .create(true)
        .open("request.ts")
    {
        file.write_all(request.as_bytes())?;
    }

    if !map.lock().unwrap().is_empty() {
        let mut file = OpenOptions::new()
            .read(true)
            .write(true)
            .truncate(true)
            .create(true)
            .open("types.ts")?;
        let mut types = format!("// generated by https://github.com/spike2044/yapi2js\n// {}\n", now.to_rfc2822());
        for (k, v) in map.lock().unwrap().iter() {
            writeln!(types, "export type {} = {}", k, v)?;
        };
        file.write_all(types.as_bytes())?;
    }

    Ok(())
}

pub fn generate_response(item: &YapiItem, obj: &YapiObj, cb: &mut impl FnMut(String, String, usize)) -> AnyResult<String> {
    let re = Regex::new(r"^\w+$").unwrap();

    let mut set = HashSet::new();
    let mut result = String::new();

    let body = match item.res_body_type {
        ResBodyType::Json => &item.res_body,
        ResBodyType::Raw => {
            return Ok(String::new());
        }
    };
    if !re.is_match(&item.title) || body.is_none() || body == &Some(String::from("")) {
        return Ok(String::new());
    }
    let body = body.as_ref().ok_or_else(|| anyhow!("no res_body"))?;
    let v: ResponseValueType = serde_json::from_str(body)?;
    let title = format!("{}{}", obj.name, item.title);
    if !set.contains(&title) {
        result = format!(
            "{} \n\n // path: {} {} \n export type {}{}Type = {}",
            result,
            item.method,
            item.path,
            obj.name,
            item.title,
            get_response_type_with_cb(&v, cb, 1)
        );
        set.insert(title);
    }
    Ok(result)
}

pub fn generate_request(item: &YapiItem, _obj: &YapiObj, cb: &mut impl FnMut(String, String, usize)) -> AnyResult<String> {
    let re = Regex::new(r"^\w+$").unwrap();
    let mut result = String::new();
    let mut map: HashMap<String, String> = HashMap::new();
    map.insert(String::from("text"), String::from("string"));
    map.insert(String::from("file"), String::from("File"));
    map.insert(String::from("number"), String::from("number"));

    let title = format!("{}RequestType", item.title);
    if !re.is_match(&item.title) {
        return Ok(String::new());
    }

    let mut req_params = item
        .req_params
        .iter()
        .map(|x| format!("{}: string\n", x.name))
        .collect::<String>();
    if !req_params.is_empty() {
        req_params = format!("\n uri: {{\n{} }}", req_params);
    }

    let mut req_query = item
        .req_query
        .iter()
        .map(|x| {
            format!(
                "{}{}: string\n",
                x.name,
                if x.required == "1" { "" } else { "?" }
            )
        })
        .collect::<String>();
    if !req_query.is_empty() {
        req_query = format!("\nparams?: {{\n{} }}", req_query);
    }

    let mut data = match item.req_body_type {
        ReqBodyType::Form => format!("{{ {} }}", item
            .req_body_form
            .iter()
            .map(|x| {
                format!(
                    "{}?: {} \n",
                    x.name,
                    map.get(&x.name)
                        .cloned()
                        .unwrap_or_else(|| "unknown".to_string())
                )
            })
            .collect::<String>()),
        ReqBodyType::Json => match item.req_body_other {
            Some(ref body) => {
                let v: ResponseValueType = serde_json::from_str(body)?;
                get_response_type_with_cb(&v, cb, 1)
            }
            None => String::from(""),
        },
    };
    if !data.is_empty() {
        data = format!("\ndata?: {} ", data);
    };

    result = format!(
        "{} \n export type {} = {{ {}{}{}\n }}",
        result, title, req_params, req_query, data
    );
    Ok(result)
}
